<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis常见八股文 | H-Loong</title><meta name="author" content="H-Loong"><meta name="copyright" content="H-Loong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis常见八股文Redis 中常见的数据类型有哪些？Redis常见的数据类型主要有五种：String、List、Set、Hash和Zset(sorted set)，高级数据结构有BitMap、HyperLogLog、GEO、stream String: 可以存储任何类型的数据，包括文本、数字和二进制数据，最大长度512MB ​			场景： 缓存（用户会话、页面缓存）、计数器（统计访问量、点赞数">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis常见八股文">
<meta property="og:url" content="https://h-loong.github.io/2025/01/07/Redis%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="H-Loong">
<meta property="og:description" content="Redis常见八股文Redis 中常见的数据类型有哪些？Redis常见的数据类型主要有五种：String、List、Set、Hash和Zset(sorted set)，高级数据结构有BitMap、HyperLogLog、GEO、stream String: 可以存储任何类型的数据，包括文本、数字和二进制数据，最大长度512MB ​			场景： 缓存（用户会话、页面缓存）、计数器（统计访问量、点赞数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/04/14/OREnG52wk1Z3IXf.jpg">
<meta property="article:published_time" content="2025-01-07T07:20:21.000Z">
<meta property="article:modified_time" content="2025-02-16T11:14:55.233Z">
<meta property="article:author" content="H-Loong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/04/14/OREnG52wk1Z3IXf.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://h-loong.github.io/2025/01/07/Redis%E5%85%AB%E8%82%A1%E6%96%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?f0523347b983847f8af63b11968b815c;";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis常见八股文',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-16 19:14:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/14/OREnG52wk1Z3IXf.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="H-Loong"><span class="site-name">H-Loong</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis常见八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-07T07:20:21.000Z" title="发表于 2025-01-07 15:20:21">2025-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-16T11:14:55.233Z" title="更新于 2025-02-16 19:14:55">2025-02-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis常见八股文"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis常见八股文"><a href="#Redis常见八股文" class="headerlink" title="Redis常见八股文"></a>Redis常见八股文</h1><h3 id="Redis-中常见的数据类型有哪些？"><a href="#Redis-中常见的数据类型有哪些？" class="headerlink" title="Redis 中常见的数据类型有哪些？"></a>Redis 中常见的数据类型有哪些？</h3><p>Redis常见的数据类型主要有五种：<strong>String、List、Set、Hash和Zset(sorted set)<strong>，高级数据结构有</strong>BitMap、HyperLogLog、GEO、stream</strong></p>
<p><strong>String:</strong> 可以存储任何类型的数据，包括文本、数字和二进制数据，最大长度512MB</p>
<p>​			<strong>场景：</strong> 缓存（用户会话、页面缓存）、计数器（统计访问量、点赞数等）</p>
<p><strong>List:</strong> 列表是有序的字符串集合，支持从两端插入和弹出。可以用做队列或栈，底层双向链表</p>
<p>​			<strong>场景：</strong> 消息队列（任务调度、消息传递等）、历史记录</p>
<p><strong>Set:</strong> 集合是无序且不重复的字符串集合，哈希表实现，可以实现快速查询，和去重操作</p>
<p>​			<strong>场景：</strong> 标签存储、去重（如统计独立IP）</p>
<p><strong>Hash:</strong> 存储键值对集合，适合存储对象。内部类似于一个小型的键值对集合</p>
<p>​			<strong>场景：</strong> 存储用户信息，存储配置数据</p>
<p><strong>Zset:</strong> 类似于Set，但每个元素会关联一个分数，自动按分数排序。支持快速的范围查询</p>
<p>​			<strong>场景：</strong> 排行榜，任务调度（优先级）</p>
<p><strong>BitMap:</strong> 一种以位为单位存储数据的高效方式，适合用来表示布尔值（存在性、状态）</p>
<p>​			<strong>场景：</strong> 用户在线状态</p>
<p><strong>HyperLogLog:</strong> 一种概率性数据结构，主要用于估算基数，适合大规模处理数据的去重和计数</p>
<p><strong>GEO：</strong> 一种用于存储地理位置信息的数据结构。</p>
<p><strong>Stream:</strong> 一种日志数据结构，适合存储时间序列数据或消息流。</p>
<hr>
<h3 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h3><p>redis快的原因</p>
<p>首先是因为<strong>redis存储在内存</strong>中，提供了快速的读写速度，内存的访问速度远快于磁盘，能够达到微秒级的响应时间。虽然数据存储在内存中，但 Redis 支持持久化（RDB、AOF）以保证数据安全。</p>
<p>其次是<strong>单线程模型</strong>，Redis 使用单线程模型处理请求，避免了多线程的上下文切换和锁竞争。</p>
<p>最后是<strong>redis拥有高效的数据结构</strong>，Redis 使用高度优化的底层数据结构（如哈希表、跳表、压缩列表等）操作复杂度低，常见操作都是 O(1) 或 O(logN)。</p>
<p>针对不同场景选择最佳数据结构，减少时间和空间消耗。</p>
<hr>
<h3 id="为什么-Redis-设计为单线程？6-0-版本为何引入多线程？"><a href="#为什么-Redis-设计为单线程？6-0-版本为何引入多线程？" class="headerlink" title="为什么 Redis 设计为单线程？6.0 版本为何引入多线程？"></a>为什么 Redis 设计为单线程？6.0 版本为何引入多线程？</h3><p>Redis 在早期的设计中采用了 <strong>单线程模型</strong>，主要是为了追求<strong>极致的简单性和性能</strong>，但从 <strong>6.0</strong> 版本开始引入了多线程支持。</p>
<p><strong>设计成单线程的原因：</strong> </p>
<p>避免多线程的复杂性：多线程需要处理线程间的竞争、锁、上下文切换等问题，这会导致编程复杂性和性能瓶颈。单线程模型避免了锁的引入，避免了死锁、资源争用等问题。</p>
<p>充分利用 CPU 性能：对于大多数场景，Redis 的性能瓶颈并不在于 CPU，而是在<strong>内存访问速度和网络 I&#x2F;O</strong>。单线程可以完全用 <code>epoll</code> 等 I&#x2F;O 多路复用机制高效地处理并发请求，而 CPU 通常不会成为瓶颈。</p>
<p><strong>引入多线程的原因：</strong></p>
<p>主要是为了解决<strong>高并发场景下网络 I&#x2F;O 的瓶颈</strong>，充分利用多核 CPU 的资源</p>
<hr>
<h3 id="Redis-中跳表的实现原理是什么？"><a href="#Redis-中跳表的实现原理是什么？" class="headerlink" title="Redis 中跳表的实现原理是什么？"></a>Redis 中跳表的实现原理是什么？</h3><p>首先跳表是什么？</p>
<p><strong>跳表</strong>是一种用于实现有序集合（Sorted Set）数据结构的算法。它提供了一种快速的方式来查找、插入和删除元素，尤其适用于大规模的数据存储场景。</p>
<p>跳表是一种<strong>多级链表结构</strong> ，底层链表保存所有元素，而每一层链表都是下一层的子集。</p>
<p>实现原理：</p>
<ul>
<li><p><strong>查找操作</strong></p>
<p> 从最高层索引的头节点开始， </p>
<ul>
<li>如果当前节点的下一个节点的值小于要查找的值，则向右移动；</li>
<li>如果当前节点的下一个节点的值大于要查找的值，则向下移动，</li>
<li>直到找到目标值或者确定目标值不存在。</li>
</ul>
</li>
<li><p><strong>插入操作</strong> 首先进行查找操作，找到插入位置。然后随机生成一个层数，根据这个层数在每一层插入新节点。 </p>
</li>
<li><p><strong>删除操作：</strong> 首先进行查找操作，找到要删除的节点。然后在每一层删除这个节点。</p>
</li>
</ul>
<hr>
<h3 id="Redis-的-hash-是什么？"><a href="#Redis-的-hash-是什么？" class="headerlink" title="Redis 的 hash 是什么？"></a>Redis 的 hash 是什么？</h3><p><strong>Redis</strong> 的hash是一种键值对集合，非常适合存储对象类型的数据，如用户信息，商品信息等，可以提供高效的查询和更新操作。</p>
<p>应用场景：</p>
<p><strong>存储用户信息</strong>：假设你有一个用户管理系统，你可以为每个用户创建一个 <code>hash</code>，将其用户名、邮箱、密码等信息存储在该 <code>hash</code> 中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET user:1001 username <span class="string">&quot;johndoe&quot;</span> email <span class="string">&quot;john@example.com&quot;</span> password <span class="string">&quot;hashedpassword&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以方便的对对象的其中某一个字段进行修改，而不像<code>string</code>需要全部修改</p>
<hr>
<h3 id="Redis-Zset-的实现原理是什么？"><a href="#Redis-Zset-的实现原理是什么？" class="headerlink" title="Redis Zset 的实现原理是什么？"></a>Redis Zset 的实现原理是什么？</h3><p>Redis 中的<code>Zset</code>的实现原理主要是结合了 <strong>跳表</strong> 和 <strong>哈希表</strong> 这两种数据结构。</p>
<p><strong>跳表</strong>用于按分数对元素进行排序，可以提供高效的查询和范围查询能力。</p>
<p><strong>哈希表</strong>用于存储成员与分数的映射，提供快速查找</p>
<p>内存优化：</p>
<p>Redis 会对 <code>Zset</code> 进行内存优化。对于元素较少的 <code>Zset</code>，Redis 会使用 <strong>Ziplist</strong> 编码来减少内存消耗。当有序集合中的元素数量超过一定阈值时，Redis 会切换到使用跳表和哈希表的方式。</p>
<hr>
<h3 id="Redis-中如何保证缓存与数据库的数据一致性？"><a href="#Redis-中如何保证缓存与数据库的数据一致性？" class="headerlink" title="Redis 中如何保证缓存与数据库的数据一致性？"></a>Redis 中如何保证缓存与数据库的数据一致性？</h3><ol>
<li><p><strong>先更新缓存，再更新数据库</strong></p>
<p>网络会出现顺序不一致，导致数据不一致</p>
</li>
<li><p><strong>先更新数据库，再更新缓存</strong></p>
<p>网络会出现顺序不一致，导致数据不一致</p>
</li>
<li><p><strong>先删除缓存，再更新数据库，后续查询将数据库数据回存到缓存中</strong></p>
<p>网络可能会导致回存的数据是过时数据</p>
</li>
<li><p><strong>先更新数据库，再删除缓存，后续查询将数据库数据回存到缓存中</strong></p>
<p>一定时间内可能不一致，保证最终一致性，可能存在缓存失效后恰好数据库更新的删除缓存失败，缓存更新为过期数据，而数据库中为最新数据不一致</p>
</li>
<li><p><strong>缓存双删策略，更新数据库前，删除一次缓存，更新完后再延迟删除一次</strong></p>
<p>避免了过期数据被回存导致的不一致</p>
</li>
<li><p><strong>使用binog异步更新缓存，监听数据库Binog变化，通过异步方式更新Redis缓存</strong></p>
<p>先修改数据库，通过Canal监听数据库的binlog日志，记录修改信息，通过消息队列异步修改缓存的数据</p>
</li>
</ol>
<p><strong>实时一致性</strong>：先写数据库，再删除缓存，短期可能数据不一致</p>
<p><strong>最终一致性</strong>：推荐使用binlog+消息队列，顺序消费加上重试机制保证最终一致性</p>
<p><strong>强一致性</strong>：</p>
<ol>
<li>通过分布式读写锁实现，读和读操作不互斥，读写互斥，写写互斥。</li>
<li>写操作:获取写锁，更新数据库，删除缓存，释放写锁</li>
<li>读操作:获取读锁，查询缓存，命中缓存释放锁，返回结果。未命中读取数据库，更新到缓存后，释放读锁</li>
</ol>
<hr>
<h3 id="Redis-中的缓存击穿、缓存穿透和缓存雪崩是什么？"><a href="#Redis-中的缓存击穿、缓存穿透和缓存雪崩是什么？" class="headerlink" title="Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？"></a>Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？</h3><p><strong>缓存击穿：</strong> 是指某个热点数据在缓存中过期了，导致该热点数据的大量请求直接访问数据库，造成数据库压力过大，导致崩溃</p>
<p><strong>缓存穿透：</strong> 是指查询一个不存在于缓存之中的数据，导致每次请求都回去数据库查询，造成数据库压力大</p>
<p><strong>缓存雪崩：</strong> 是指多个缓存数据在同一时间过期，导致这些数据的大量请求同时访问数据库，导致数据库压力过大</p>
<p><strong>概括：击穿-热点过期  穿透-查询不存在的  雪崩-大量同时过期</strong></p>
<p><strong>扩展：</strong></p>
<p><strong>缓存击穿：</strong> 比如大家都在抢茅台，但某一时刻茅台的缓存失效了，大家都请求打到了数据库中，这就是缓存击穿。</p>
<p><strong>缓存击穿现象：</strong></p>
<ol>
<li>数据库访问压力瞬时增加</li>
<li>redis里面没有大量的key过期</li>
<li>redis正常运行，但是数据库可能已经瘫痪了</li>
</ol>
<p><strong>解决方案：</strong></p>
<ol>
<li><p><strong>设置热门数据</strong></p>
<p>在redis高峰访问之前，把一些热门数据提前存入redis里面，加大这些热门数据key的时长。</p>
<p>或者不要给热门数据设置过期时间，在后台异步更新缓存</p>
</li>
<li><p><strong>使用锁</strong></p>
<p>保证同一时间只有一个请求来构建缓存</p>
</li>
</ol>
<p><strong>缓存穿透：</strong> 攻击者可以通过构造不存在的key发起大量请求，对数据库造成很大的压力，可能会造成系统宕机。</p>
<p><strong>缓存穿透的现象：</strong></p>
<ol>
<li>应用服务器压力变大</li>
<li>redis命中率降低</li>
<li>一直查数据库</li>
</ol>
<p><strong>解决方案：</strong></p>
<ol>
<li><p><strong>对空值缓存</strong></p>
<p>如果一个查询返回的数据为空，将这个空值也缓存起来，避免频繁查询数据库，设置空结果的过期时间应该短些，不超过五分钟。</p>
</li>
<li><p><strong>设置可访问白名单</strong></p>
<p>定义一个可以访问的名单，每次访问和白名单的 id 进行比较，如果访问 id 不在白名单里面，进行拦截，不允许访问, 比如使用 bitmaps 实现 。</p>
</li>
<li><p><strong>使用布隆过滤器</strong></p>
<p>使用布隆过滤器来快速判断一个请求的数据是否存在，如果布隆过滤器判断数据不存在，则直接返回，避免查询数据库。</p>
</li>
<li><p><strong>实时监控</strong></p>
<p>当发现 Redis 的命中率开始急速降低, 需要排查访问对象和访问的数据, 和运维人员配合,可以设置黑名单限制服务  。</p>
</li>
</ol>
<p><strong>缓存雪崩：</strong> 比如一个电商系统，用户量很大，假设某一系列商品缓存突然同一时间失效，那就会造成缓存雪崩，导致服务全部打到数据库，引发严重后果</p>
<p><strong>缓存雪崩的现象：</strong></p>
<ol>
<li>数据库访问压力变大，服务器崩溃</li>
<li>在极短时间内，访问大量key，而这些 key 集中过期</li>
</ol>
<p><strong>解决方案：</strong></p>
<p><strong>缓存键同时失效：</strong></p>
<ol>
<li><p><strong>构建多级缓存架构</strong></p>
<p>引入多级缓存机制，如本地缓存加分布式缓存相结合，减少单点故障风险。</p>
</li>
<li><p><strong>过期时间随机化</strong></p>
<p>设置缓存过期时间时，在原油过期时间上加一个随机值，比如1-5分钟随机，这样每个缓存过期时间重复率降低，避免同一时间大量缓存失效</p>
</li>
<li><p><strong>缓存预热</strong></p>
<p>系统启动前提前加载缓存数据，避免大量请求落到冷启动状态下的数据库</p>
</li>
<li><p><strong>加互斥锁</strong></p>
<p>使得没缓存或缓存失效的情况下，同一时间只有一个请求来构建缓存，防止数据库压力过大。</p>
</li>
</ol>
<hr>
<h3 id="Redis-String-类型的底层实现是什么？（SDS）"><a href="#Redis-String-类型的底层实现是什么？（SDS）" class="headerlink" title="Redis String 类型的底层实现是什么？（SDS）"></a>Redis String 类型的底层实现是什么？（SDS）</h3><p>Redis 中 <code>String</code> 类型的底层实现是 <strong>简单动态字符串（SDS, Simple Dynamic String）</strong>。并结合int、embstr、raw等不同编码方式进行优化。</p>
<p><strong>扩展：</strong></p>
<p><strong>SDS:</strong> 当我们操作一个 SDS 字符串时，Redis 会预留一定的空间用于追加内容，而不是每次操作都重新分配内存。</p>
<p>如果你向 SDS 中追加字符串，SDS 会在 <code>free</code> 空间用完时自动扩展内存。如果内存使用率非常高，SDS 也可以根据需要减少分配的内存大小，从而避免浪费。</p>
<p><strong>不同编码方式：</strong></p>
<p><strong>Int</strong>  当字符串可以表示为一个整数时，Redis 会使用 <code>int</code> 编码。这种编码方式非常高效，因为它直接将字符串存储为整数，而不是像传统的字符串一样存储字符数组。</p>
<p> <strong>Embstr</strong>  <code>embstr</code> 编码是一种针对短字符串优化的编码方式。当字符串的长度较短时（通常为 39 字节或更少），Redis 会将字符串数据和 <code>SDS</code> 头部存储在一个连续的内存块中，从而减少内存分配的次数和内存碎片。</p>
<p><strong>Raw</strong>   <code>raw</code> 编码是 Redis 中最常见的字符串编码方式，用于较长的字符串。与 <code>embstr</code> 编码不同，<code>raw</code> 编码将字符串的数据和 <code>SDS</code> 头部分开存储，适用于长度较长的字符串。Redis 会将字符串数据存储在堆内存中，并在 <code>SDS</code> 头部记录相关的元数据（如字符串长度、剩余可用空间等）。</p>
<hr>
<h3 id="Redis-中如何实现分布式锁？"><a href="#Redis-中如何实现分布式锁？" class="headerlink" title="Redis 中如何实现分布式锁？"></a>Redis 中如何实现分布式锁？</h3><p>Redis中实现分布式锁常见方法是：通过<code>set ex nx</code>命令+lua脚本组合使用。</p>
<p><strong>具体实现：</strong></p>
<ol>
<li><p>指令：<code>setnx key value </code></p>
<p>- setnx 可以理解是上锁&#x2F;加锁指令<br>- key 是锁的键<br>- value 是锁的值<br>- 在这个 key 没有删除前, 不能执行相同 key 的上锁指令.  </p>
</li>
<li><p>指令：<code>del key</code></p>
<p>删除key，这里可以理解为释放锁</p>
</li>
<li><p>指令：<code>expire key seconds</code></p>
<p>给锁key设置过期时间，防止死锁</p>
</li>
<li><p>指令：<code>ttl key</code></p>
<p>查看某个锁key的过期时间，-1代表永不过期     -2代表已过期</p>
</li>
<li><p>指令：<code>set key value nx ex seconds</code></p>
<p>设置锁的同时，指定该锁的过期时间</p>
<p>这个指令是原子性的，防止 <code>setnx key value / expire key seconds</code> 两条指令, 中间执行被打断</p>
</li>
</ol>
<p><strong>Java简单实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;testLock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (lock)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(value.toString()))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>,++num);</span><br><span class="line">            redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                testLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时没有设置过期时间，容易造成死锁，所以需要加上过期时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;ok&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>过期时间为三秒，但此时又产生了新的问题，如果业务操作出现了卡顿，导致锁超时，自动释放，此时其他用户将上锁进行业务操作，而当第一个用户业务操作结束后，要删除锁，此时删除的并不是自己上的锁，而是后面用户上的锁，就出现了<strong>误删锁问题</strong>，要解决该问题，可以采用<strong>UUID防误删锁</strong>。</p>
<p><strong>思路分析：</strong></p>
<ol>
<li>在获取锁的时候, 给锁设置的值是唯一的 uuid</li>
<li>在释放锁时,判断释放的锁是不是同一把锁.</li>
<li>造成这个问题的本质原因, 是因为删除操作缺乏原子性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到一个 uuid 值，作为锁的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">..........</span><br><span class="line"><span class="comment">//为了防止误删锁, 进行判断</span></span><br><span class="line"><span class="comment">//判断当前这个锁是不是前面获取到的锁, 相同才进行删除/释放</span></span><br><span class="line"><span class="keyword">if</span> (uuid.equals((String) redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>))) &#123;</span><br><span class="line">redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时虽然能保证大部分不会误删锁，但是考虑到一个极端问题，如果当刚判断完当前锁是前面获取到的锁，此时正好该锁过期了，然后第二个用户已经又上锁了，此时第一个用户进行删除锁操作，就会把第二个用户的锁删除。要解决该问题就得用<strong>lua脚本保证删除原子性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=====使用 lua 脚本来锁, 控制删除原子性========</span></span><br><span class="line"><span class="comment">// 定义 lua 脚本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 redis 执行 lua 执行</span></span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line"><span class="comment">// 设置一下返回值类型 为 Long</span></span><br><span class="line"><span class="comment">// 因为删除判断的时候，返回的 0,给其封装为数据类型。如果不封装那么默认返回 String 类</span></span><br><span class="line">型，</span><br><span class="line"><span class="comment">// 那么返回字符串与 0 会有发生错误。</span></span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line"><span class="comment">// 第一个是 script 脚本 ，第二个需要判断的 key，第三个就是 key 所对应的值</span></span><br><span class="line"><span class="comment">// Arrays.asList(&quot;lock&quot;) 会 传 递 给 script 的 KEYS[1] , uuid 会 传 递 给ARGV[1] </span></span><br><span class="line">redisTemplate.execute(redisScript, Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>定义锁的 key, key 可以根据业务, 分别设置， 比如操作某商品, key 应该是为每个 sku 定义的， 也就是每个 sku 有一把锁  </li>
<li>为了确保分布式锁可用，要确保锁的实现同时满足以下四个条件：  <ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>加锁和解锁必须是同一个客户端，A 客户端不能把 B 客户端加的锁给解了</li>
<li>加锁和解锁必须具有原子性</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Redis-的-Red-Lock-是什么？你了解吗？"><a href="#Redis-的-Red-Lock-是什么？你了解吗？" class="headerlink" title="Redis 的 Red Lock 是什么？你了解吗？"></a>Redis 的 Red Lock 是什么？你了解吗？</h3><p><strong>Red Lock</strong>是一种分布式锁算法，用于在分布式系统中实现可靠的锁机制。它的设计解决了单一Redis实例作为分布式锁可能出现的单点故障问题‌。</p>
<p><strong>一般情况存在的问题</strong></p>
<p>一般使用主从+哨兵实现redis，如果发生了主从切换，此时从节点如果还没有同步主节点的锁信息，，新的主节点便没有锁信息，此时某个业务去加锁，此时该业务和主从切换之前加锁的业务就产生了竞争，会导致数据不一致问题。</p>
<p><strong>RedLock的实现原理</strong></p>
<p>RedLock不在单个Redis实例上加锁，而是在多个独立的Redis实例上同时尝试获取锁。通常建议使用奇数个Redis实例（如5个），以确保系统具有较好的容错性。系统只有在获得了大多数Redis实例的锁（即N&#x2F;2 + 1个节点，N为节点总数）之后，才认为成功获取了分布式锁。这样即使部分Redis实例发生故障，整体锁服务仍然可用‌。</p>
<p><strong>RedLock的具体流程</strong></p>
<ol>
<li>‌<strong>获取锁</strong>‌：客户端尝试顺序地向所有Redis实例发送加锁命令。对于每个实例，客户端在指定的超时时间内尝试获取锁。</li>
<li>‌<strong>计算成功加锁的实例数量</strong>‌：客户端计算已经成功加锁的实例数量，如果达到多数（N&#x2F;2 + 1），则认为客户端成功获取了分布式锁。</li>
<li>‌<strong>释放锁</strong>‌：如果获取锁失败，客户端需要向所有实例发送释放锁的命令，以避免留下未释放的锁‌。</li>
</ol>
<hr>
<h3 id="Redis-实现分布式锁时可能遇到的问题有哪些？"><a href="#Redis-实现分布式锁时可能遇到的问题有哪些？" class="headerlink" title="Redis 实现分布式锁时可能遇到的问题有哪些？"></a>Redis 实现分布式锁时可能遇到的问题有哪些？</h3><ol>
<li><p><strong>业务逻辑未执行完，锁已过期</strong></p>
<p>如果业务逻辑执行时间过长，而锁已经过期，就会导致过期后，被其他业务加锁的情况，导致并发问题</p>
<p>可以引入续锁机制、合理设置锁过期时间</p>
</li>
<li><p><strong>锁被误释放</strong></p>
<p>业务A上锁执行操作，但由于网络卡顿，导致锁超时，此时业务B上锁进行操作,此时业务A操作结束,需要释放锁，就将业务B的锁给释放了，出现误删锁问题</p>
<p>可以采用UUID防误删锁（在释放锁时判断是不是同一把锁）</p>
</li>
<li><p><strong>原子性不足</strong></p>
<p>在一个极端情况下，当刚判断完当前锁就是自己前面加的锁，准备要去释放，此时锁过期，然后另一个业务加了锁，此时第一个业务进行了释放锁，还是导致了误删锁。</p>
<p>此时就要用lua脚本保证删除原子性</p>
</li>
<li><p><strong>单点故障问题</strong></p>
<p>如果Redis是单机部署的，当该服务宕机，那么整个分布式锁都不可用</p>
<p>可以采用主从+哨兵形式部署，引入RedLock,通过在多个独立的 Redis 实例上实现锁的冗余，确保分布式锁的安全性和容错性</p>
</li>
<li><p><strong>时钟漂移问题</strong></p>
<p>分布式环境中，服务器时钟可能不同步，导致时间计算不准确，导致加锁或释放锁失败</p>
<p>使用NTP，同步服务器时钟</p>
</li>
</ol>
<hr>
<h3 id="Redis-的持久化机制有哪些？"><a href="#Redis-的持久化机制有哪些？" class="headerlink" title="Redis 的持久化机制有哪些？"></a>Redis 的持久化机制有哪些？</h3><p>Redis提供了两种持久化机制，<strong>RDB和AOD</strong>。</p>
<p><strong>RDB（Redis Database Backup）快照：</strong> RDB是通过生成某一时刻都数据快照来实现持久化，可以在特定时间间隔内保存数据的快照，但是RDB在奔溃时，可能会丢失最后一次快照之后的数据。</p>
<p><strong>AOF（Append Only File）日志：</strong> AOF是通过将每个写操作追加到日志文件中实现持久化，数据恢复更精确，但文件体积较大，重写也会消耗更多资源。</p>
<p><strong>扩展：</strong></p>
<h4 id="RDB执行流程"><a href="#RDB执行流程" class="headerlink" title="RDB执行流程"></a>RDB执行流程</h4><ol>
<li>在指定的时间间隔内将内存中的数据集快照<strong>写入磁盘</strong>，也就是Snapshot快照，恢复时将快照文件读入内存。</li>
<li>RDB是redis默认持久化策略。</li>
<li><strong>具体流程</strong>如下：<ol>
<li>redis 客户端执行 <code>bgsave</code> 命令或者自动触发 <code>bgsave</code> 命令；</li>
<li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li>
<li>如果不存在正在执行的子进程，那么就 fork 一个新的子进程进行持久化数据，fork 过程是阻塞的，fork 操作完成后主进程即可执行其他操作；</li>
<li>子进程先将数据写入到<strong>临时</strong>的 rdb 文件中，待快照数据写入完成后再原子替换旧的 rdb文件；</li>
<li>同时发送信号给主进程，通知主进程 rdb 持久化完成，主进程更新相关的统计信息</li>
</ol>
</li>
<li><strong>优缺点</strong>：<ul>
<li>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能</li>
<li>如果需要进行大规模数据的恢复，切对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加高效</li>
<li>RDB的缺点是最后一次持久化后的数据可能丢失（如果是正常关闭redis，仍然会进行持久化，不会造成数据丢失，如果是redis异常终止&#x2F;宕机，就会造成数据丢失）</li>
</ul>
</li>
</ol>
<h4 id="Fork-Copy-On-Write"><a href="#Fork-Copy-On-Write" class="headerlink" title="Fork&amp;Copy-On-Write"></a>Fork&amp;Copy-On-Write</h4><ol>
<li>Fork的作用是复制一个与当前进程一样的进程，新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</li>
<li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux引入了“<strong>写时复制技术</strong> 即：Copy-on-Write”</li>
<li>一般情况父进程和子进程会同用一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>
</ol>
<h4 id="RDB配置"><a href="#RDB配置" class="headerlink" title="RDB配置"></a>RDB配置</h4><p><strong>dump.rdb文件</strong></p>
<ol>
<li><p>快照文件默认为dump.rdb，在redis.conf中可以配置</p>
</li>
<li><p>dump.rdb保存位置默认为：redis启动命令行所在的目录下</p>
<p>在哪个目录下启动，dump.rdb就保存在哪，如果每次启动位置不一致，会导致数据恢复时缺失，所以最好讲rdb文件的保存路径进行统一设置，不论在哪启动都将数据保存在一个rdb文件中。</p>
</li>
</ol>
<p>如果没有开启save的注释，那么在退出redis时，也会进行备份，更新dump.rdb</p>
<p><strong>save &amp; bgsave</strong></p>
<ol>
<li>save：用save命令时，只进行保存，其他不管，会导致客户端其他命令阻塞，直到 RDB 过程完成为止，对于内存比较大的实例造成长时间阻塞，基本不采用；</li>
<li>bgsave：Redis 会在后台异步进行快照操作， 快照同时还可以响应客户端请求。  阻塞只发生在 fork 创建进程阶段，这个时间很短；</li>
<li>可以通过 lastsave 命令获取最后一次成功执行快照的时间(unix 时间戳) , 可以使用工具<strong>转换</strong>  </li>
<li>禁用save：给save传入空字符串   动态停止 RDB： redis-cli config set save “”</li>
</ol>
<p><strong>flushall</strong></p>
<ol>
<li>清空整个redis 服务器的数据（删除所有数据库的所有数据）</li>
<li>同时也会产生dump.rdb，只不过数据为空</li>
</ol>
<p><strong>stop-write-on-bgsave-error</strong></p>
<p>当redis无法写入磁盘的话（比如磁盘满了），直接关掉redis的写操作</p>
<p><strong>rdbcompression</strong></p>
<ol>
<li>对于存储在磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩</li>
<li>如果不想消耗CPU来进行压缩的话，可以设置为关闭此功能，默认yes</li>
</ol>
<h4 id="RDB备份-恢复"><a href="#RDB备份-恢复" class="headerlink" title="RDB备份&amp;恢复"></a>RDB备份&amp;恢复</h4><p><strong>重要&#x2F;敏感的数据建议在MySQL保存一份</strong></p>
<ol>
<li><p>查询rdb文件目录</p>
<p>将dump.rdb进行备份，如果有必要可以写shell脚本来定时备份。</p>
</li>
<li><p>清空数据</p>
</li>
<li><p>删除dump.rdb</p>
</li>
<li><p>将备份文件改名并重启redis</p>
</li>
<li><p>数据恢复</p>
</li>
</ol>
<h4 id="RDB优势-劣势"><a href="#RDB优势-劣势" class="headerlink" title="RDB优势&amp;劣势"></a>RDB优势&amp;劣势</h4><p><strong>优势：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ol>
<p><strong>劣势：</strong></p>
<ol>
<li>虽然redis在fork时使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能</li>
<li>在备份周期在一定时间间隔做一次备份，如果redis意外down掉（如果正常关闭redis，仍然会进行RDB备份，不会丢失数据），就会丢失最后一次快照后的所有改动。</li>
</ol>
<h3 id="AOF（Append-Of-File）"><a href="#AOF（Append-Of-File）" class="headerlink" title="AOF（Append Of File）"></a>AOF（Append Of File）</h3><h4 id="AOF是什么？"><a href="#AOF是什么？" class="headerlink" title="AOF是什么？"></a>AOF是什么？</h4><ol>
<li>以日志的形式来记录每个写操作（增量保存），将redis执行过的都所有写指令记录下来（比如set&#x2F;del 操作会被记录，读操作get不会被记录）</li>
<li>只许追加文件但不可以改写文件</li>
<li>redis启动之初会读取该文件重构数据</li>
<li>redis重启动的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li>
</ol>
<h4 id="AOF执行流程"><a href="#AOF执行流程" class="headerlink" title="AOF执行流程"></a>AOF执行流程</h4><ol>
<li>客户端的请求写命令会被append追加到AOF缓冲区内</li>
<li>AOF缓冲区根据AOF持久化策略【always、everysec、no】将操作sync同步到磁盘的AOF文件中</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量</li>
<li>redis服务重启时，会重新load加载AOF文件中的写操作达到恢复数据的目的</li>
</ol>
<h4 id="AOF开启"><a href="#AOF开启" class="headerlink" title="AOF开启"></a>AOF开启</h4><ol>
<li><p>在redis.conf文件中配置</p>
</li>
<li><p>AOF文件的保存路径，和RDB的路径一致</p>
</li>
<li><p>AOF和RDB同时开启时，系统默认取AOF的数据</p>
</li>
</ol>
<h4 id="AOF演示"><a href="#AOF演示" class="headerlink" title="AOF演示"></a>AOF演示</h4><ol>
<li><p>开启AOF</p>
</li>
<li><p>重启redis服务，查看AOF文件，大小为0</p>
</li>
<li><p>对redis进行操作</p>
</li>
<li><p>查看AOF文件</p>
</li>
</ol>
<h4 id="AOF备份-恢复"><a href="#AOF备份-恢复" class="headerlink" title="AOF备份&amp;恢复"></a>AOF备份&amp;恢复</h4><p>AOF 的备份机制和性能虽然和 RDB 不同, 但是备份和恢复的操作同 RDB 一样, 都是拷贝备<br>份文件, 需要恢复时再拷贝到 Redis 工作目录下， 启动系统即加载  </p>
<p><strong>正常恢复：</strong></p>
<ol>
<li>修改默认的 appendonly no， 改为 yes</li>
<li>将有数据的 aof 文件定时备份, 需要恢复时, 复制一份保存到对应目录(查看目录：config<br>get dir)</li>
<li>恢复：重启 redis 然后重新加载</li>
</ol>
<p><strong>异常恢复：</strong></p>
<p>遇到AOF文件损坏，通过<code>/usr/local/bin/redis-check-aof --fix appendonly.aof</code> 进行恢复 </p>
<p><strong>示例：</strong></p>
<ol>
<li><p>当前数据</p>
</li>
<li><p>在AOF文件后添加内容，破坏AOF文件</p>
</li>
<li><p>重启redis，发现启动失败</p>
</li>
<li><p>使用<code>/usr/local/bin/redis-check-aof --fix appendonly.aof</code>修复</p>
</li>
<li><p>重启，可以使用了</p>
</li>
<li><p>修复文件可能会造成数据丢失，但总比完全不能用好</p>
</li>
</ol>
<h4 id="AOF同步频率"><a href="#AOF同步频率" class="headerlink" title="AOF同步频率"></a>AOF同步频率</h4><ol>
<li>**appendfsync always :**始终同步，每次redis都写入都会立刻写入日志；性能较差，但数据完整性较好</li>
<li>**appendfsync everysec:**【**默认**】每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能会丢失</li>
<li>**appendfsync no:**redis不主动同步，把同步时机交给操作系统</li>
</ol>
<h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h4><ol>
<li>AOF 文件越来越大，需要定期对 AOF 文件进行重写达到压缩</li>
<li>旧的 AOF 文件含有无效命令会被忽略，保留最新的数据命令 , 比如 set a a1 ; set a b1 ;set a c1; 保留最后一条指令就可以了</li>
<li>多条写命令可以合并为一个 , 比如 set a c1 b b1 c c1</li>
<li>AOF 重写降低了文件占用空间</li>
<li>更小的 AOF 文件可以更快的被 redis 加载</li>
</ol>
<p><strong>手动触发：</strong></p>
<p>直接调用<code>bgrewriteaof</code>命令</p>
<p><strong>自动触发：</strong></p>
<ol>
<li>auto-aof-rewrite-min-size: AOF 文件最小重写大小, 只有当 AOF 文件大小大于该值时候才能重写, 默认配置 64MB</li>
<li>auto-aof-rewrite-percentage: 当前 AOF 文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比，如 100 代表当前 AOF 文件是上次重写的两倍时候才重写</li>
<li>系统载入时或者上次重写完毕时，Redis 会记录此时 AOF 大小，设为base_size,如果 Redis 的 AOF  当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis 会对  AOF 进行重写</li>
</ol>
<h4 id="AOF优势-劣势"><a href="#AOF优势-劣势" class="headerlink" title="AOF优势&amp;劣势"></a>AOF优势&amp;劣势</h4><p><strong>优势：</strong><br>1、 备份机制更稳健， 丢失数据概率更低。<br>2、可读的日志文本，通过操作 AOF 稳健，可以处理误操作<br><strong>劣势：</strong><br>1、 比起 RDB 占用更多的磁盘空间<br>2、恢复备份速度要慢<br>3、每次读写都同步的话，有一定的性能压力  </p>
<h3 id="RDB-or-AOF"><a href="#RDB-or-AOF" class="headerlink" title="RDB  or  AOF ?"></a>RDB  or  AOF ?</h3><p>官方建议：两个都用</p>
<p>如果只做缓存：如果你只希望你的数据在服务器运行的时候存在, 你也可以不使用任何持久化方式  </p>
<hr>
<h3 id="Redis-主从复制的实现原理是什么？"><a href="#Redis-主从复制的实现原理是什么？" class="headerlink" title="Redis 主从复制的实现原理是什么？"></a>Redis 主从复制的实现原理是什么？</h3><p><strong>主从复制流程：</strong></p>
<ol>
<li>Slave 启动成功连接到 master 后会发送一个 sync 命令</li>
<li>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后, master 将传送整个数据文件到 slave,以完成一次完全同步</li>
<li>slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中, 即 <strong>全量复制</strong></li>
<li>Master 数据变化了, 会将新的收集到的修改命令依次传给 slave, 完成同步, 即 <strong>增量复制</strong></li>
<li>但是只要是重新连接 master,一次完全同步（全量复制)将被自动执行</li>
</ol>
<p>【注意】：</p>
<ol>
<li>如果从服务器宕机了, 重新启动, 仍然可以获取 Master 的最新数据  </li>
<li>如果主服务器 宕机了, 从服务器并不会抢占为主服务器, 当主服务器恢复后, 从服务器仍然指向原来的主服务器.</li>
</ol>
<hr>
<h3 id="Redis-数据过期后的删除策略是什么？"><a href="#Redis-数据过期后的删除策略是什么？" class="headerlink" title="Redis 数据过期后的删除策略是什么？"></a>Redis 数据过期后的删除策略是什么？</h3><p>Redis过期删除策略主要有两种：<strong>惰性删除和定期删除</strong></p>
<p><strong>惰性删除：</strong> 当客户端访问某个键时，Redis 会检查该键是否过期。如果过期，则立即删除该键，并返回一个空值或错误。</p>
<ul>
<li><strong>优点</strong>：不需要额外的后台操作，过期键只会在被访问时才被删除。</li>
<li><strong>缺点</strong>：如果某些过期键从未被访问，Redis 将一直保留这些过期键，导致内存浪费。</li>
</ul>
<p><strong>定期删除：</strong>Redis 会周期性地检查一部分键，删除已经过期的键。默认情况下，Redis 每 100 毫秒会进行一次检查，随机选择约 10 个键进行过期判断。</p>
<ul>
<li><strong>优点</strong>：可以避免内存中积累大量过期键，即使这些键没有被访问。</li>
<li><strong>缺点</strong>：定期删除是一项后台操作，可能会带来一定的性能开销，尤其是在有大量过期键的情况下。</li>
</ul>
<hr>
<h3 id="如何解决-Redis-中的热点-key-问题？"><a href="#如何解决-Redis-中的热点-key-问题？" class="headerlink" title="如何解决 Redis 中的热点 key 问题？"></a>如何解决 Redis 中的热点 key 问题？</h3><p>Redis 中的热点 key 问题是由于某些 key 被频繁访问，导致 Redis 压力过大，进而影响整体性能甚至引发集群故障。</p>
<p><strong>热点 Key 拆分</strong><br>将热点数据分散到多个 Key 中，例如通过引入随机前缀，使得不同用户请求分散到多个 Key，多 Key 分布在多实例中，避免集中的访问单一 Key。</p>
<p><strong>多级缓存</strong><br>在 Redis 前增加其他缓存层（如 CDN、本地缓存），以分担 Redis 的访问压力。</p>
<p><strong>读写分离</strong><br>通过 Redis 主从架构，将读请求分发到多个从节点，从而减轻单节点压力。</p>
<p><strong>限流和降级</strong><br>在热点 Key 访问过高时，应用限流策略，减少对 Redis 的请求，或者在必要时返回降级的数据或空值。</p>
<p><strong>补充：</strong></p>
<p><strong>使用 Lua 脚本</strong><br>在 Redis 中使用 Lua 脚本执行复杂操作，避免多次网络往返并减少锁竞争。</p>
<p><strong>缓存预热</strong><br>在系统启动或高峰前，提前将热点数据加载到 Redis，减少高峰期间的访问延迟。</p>
<p><strong>动态过期策略</strong><br>为热点 Key 设置动态过期时间，防止缓存雪崩，尽量分散失效时间。</p>
<p><strong>热点 Key 监控与报警</strong><br>使用 Redis 自带的慢查询日志或者监控工具（如 Redis Insight）定期分析和监控热点 Key，及时发现问题。</p>
<p><strong>引入分布式缓存</strong><br>结合 Memcached、Ehcache 等其他缓存系统，减轻 Redis 的负担。</p>
<p><strong>使用大 Key 切片</strong><br>如果热点 Key 存储的是大对象（如列表、集合等），可以对其内容进行切片存储，分散访问量。</p>
<p><strong>使用一致性哈希</strong><br>结合分布式 Redis 集群的哈希槽机制，将 Key 均匀分布到不同的节点，避免单节点过载。</p>
<hr>
<h3 id="Redis-集群的实现原理是什么？"><a href="#Redis-集群的实现原理是什么？" class="headerlink" title="Redis 集群的实现原理是什么？"></a>Redis 集群的实现原理是什么？</h3><ol>
<li><strong>Redis 集群组成</strong>： Redis 集群是由多个 Redis 实例（节点）组成的，每个节点存储部分数据，并且各节点之间的数据不重复。</li>
<li><strong>数据分布机制</strong>：<ul>
<li>Redis 集群采用<strong>哈希槽（Hash Slot）</strong>机制来分配数据。</li>
<li>整个键空间被划分为 <strong>16384</strong> 个槽（slots）。</li>
<li>每个 Redis 节点负责一定范围的哈希槽。</li>
<li>数据的 key 经过哈希函数计算后，根据结果对 16384 取模，确定属于哪个槽，进而定位到负责该槽的节点。</li>
</ul>
</li>
<li><strong>客户端访问数据</strong>：<ul>
<li>客户端在发送请求时，会自动与集群的任意节点连接。</li>
<li>如果连接的节点存储了请求的数据，则直接返回；否则，该节点会根据哈希槽映射的规则，将请求路由到正确的节点处理。</li>
</ul>
</li>
<li><strong>作用</strong>： Redis 集群通过多个节点分担单节点的压力，实现了数据分布式存储和处理。</li>
</ol>
<hr>
<h3 id="Redis-中的-Big-Key-问题是什么？如何解决？"><a href="#Redis-中的-Big-Key-问题是什么？如何解决？" class="headerlink" title="Redis 中的 Big Key 问题是什么？如何解决？"></a>Redis 中的 Big Key 问题是什么？如何解决？</h3><p>Redis 中的 Big Key 指的是占用内存较大的键（Key），即存储的数据量或对象较大。Big Key 会带来以下问题：</p>
<p><strong>内存分布不均</strong>： 在集群模式下，如果多个 Big Key 集中在同一个节点，会导致内存分布不均，进而影响查询效率。</p>
<p><strong>操作耗时</strong>： 操作 Big Key（如读取、删除、迁移等）会消耗较长时间，可能导致 Redis 阻塞和其他命令响应变慢。</p>
<p><strong>网络流量开销</strong>： 传输 Big Key 时，因数据量大可能产生大量网络流量，增加网络传输延迟，甚至出现阻塞。</p>
<p><strong>客户端超时</strong>： 客户端执行 Big Key 操作时耗时较长，可能会导致超时错误，影响用户体验。</p>
<p><strong>如何解决：</strong></p>
<ol>
<li><strong>开发层面</strong>：</li>
</ol>
<ul>
<li><strong>数据压缩</strong>：对存储的数据进行压缩，减少占用内存后再存储到 Redis。</li>
<li><strong>拆分大 Key</strong>：将一个大 Key 拆分为多个小 Key。例如，将大对象按字段或子项进行拆分，从而减少单个 Key 的内存占用。</li>
<li><strong>优化数据结构</strong>：根据存储场景选择合适的数据结构。例如，将 String 类型存储改为 Hash、Set、ZSet 等分片结构，降低大 Key 的影响。</li>
</ul>
<ol start="2">
<li><strong>业务层面</strong>：</li>
</ol>
<ul>
<li><strong>减少不必要的数据</strong>：根据实际需求调整存储策略，只存储必要的数据。例如，不保存用户的历史数据，只存储实时数据或必要的信息。</li>
<li><strong>优化业务逻辑</strong>：从源头避免 Big Key 的产生，例如定期清理不需要的数据。</li>
</ul>
<ol start="3">
<li><strong>数据分布层面</strong>：</li>
</ol>
<ul>
<li><strong>Redis 集群分片</strong>：在 Redis 集群中，通过将 Big Key 拆分后分配到不同的服务器上，减少单节点压力，加快响应速度。</li>
</ul>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://H-Loong.github.io">H-Loong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://h-loong.github.io/2025/01/07/Redis%E5%85%AB%E8%82%A1%E6%96%87/">https://h-loong.github.io/2025/01/07/Redis%E5%85%AB%E8%82%A1%E6%96%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://H-Loong.github.io" target="_blank">H-Loong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/04/14/OREnG52wk1Z3IXf.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式常见八股文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式常见八股文</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/" title="MySQL数据库八股文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL数据库八股文</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/14/OREnG52wk1Z3IXf.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">H-Loong</div><div class="author-info__description">埋头去做，总会发光发热</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/H-Loong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/H-Loong" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2638102494@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2638102494&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎朋友们光临本小站！一起交流学习！（如果图片加载过慢，请使用加速器访问或耐心等待）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">Redis常见八股文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.1.</span> <span class="toc-text">Redis 中常见的数据类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.0.2.</span> <span class="toc-text">Redis 为什么这么快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E8%AE%BE%E8%AE%A1%E4%B8%BA%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F6-0-%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.0.3.</span> <span class="toc-text">为什么 Redis 设计为单线程？6.0 版本为何引入多线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%AD%E8%B7%B3%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.4.</span> <span class="toc-text">Redis 中跳表的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84-hash-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.5.</span> <span class="toc-text">Redis 的 hash 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Zset-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.6.</span> <span class="toc-text">Redis Zset 的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">1.0.7.</span> <span class="toc-text">Redis 中如何保证缓存与数据库的数据一致性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.8.</span> <span class="toc-text">Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-String-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88SDS%EF%BC%89"><span class="toc-number">1.0.9.</span> <span class="toc-text">Redis String 类型的底层实现是什么？（SDS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">1.0.10.</span> <span class="toc-text">Redis 中如何实现分布式锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84-Red-Lock-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.11.</span> <span class="toc-text">Redis 的 Red Lock 是什么？你了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%97%B6%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.12.</span> <span class="toc-text">Redis 实现分布式锁时可能遇到的问题有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.13.</span> <span class="toc-text">Redis 的持久化机制有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.13.1.</span> <span class="toc-text">RDB执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fork-Copy-On-Write"><span class="toc-number">1.0.13.2.</span> <span class="toc-text">Fork&amp;Copy-On-Write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E9%85%8D%E7%BD%AE"><span class="toc-number">1.0.13.3.</span> <span class="toc-text">RDB配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%A4%87%E4%BB%BD-%E6%81%A2%E5%A4%8D"><span class="toc-number">1.0.13.4.</span> <span class="toc-text">RDB备份&amp;恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E4%BC%98%E5%8A%BF-%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.0.13.5.</span> <span class="toc-text">RDB优势&amp;劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%EF%BC%88Append-Of-File%EF%BC%89"><span class="toc-number">1.0.14.</span> <span class="toc-text">AOF（Append Of File）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.14.1.</span> <span class="toc-text">AOF是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.14.2.</span> <span class="toc-text">AOF执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E5%BC%80%E5%90%AF"><span class="toc-number">1.0.14.3.</span> <span class="toc-text">AOF开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%BC%94%E7%A4%BA"><span class="toc-number">1.0.14.4.</span> <span class="toc-text">AOF演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E5%A4%87%E4%BB%BD-%E6%81%A2%E5%A4%8D"><span class="toc-number">1.0.14.5.</span> <span class="toc-text">AOF备份&amp;恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E5%90%8C%E6%AD%A5%E9%A2%91%E7%8E%87"><span class="toc-number">1.0.14.6.</span> <span class="toc-text">AOF同步频率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rewrite%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.0.14.7.</span> <span class="toc-text">Rewrite压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E4%BC%98%E5%8A%BF-%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.0.14.8.</span> <span class="toc-text">AOF优势&amp;劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-or-AOF"><span class="toc-number">1.0.15.</span> <span class="toc-text">RDB  or  AOF ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.16.</span> <span class="toc-text">Redis 主从复制的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E5%90%8E%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.17.</span> <span class="toc-text">Redis 数据过期后的删除策略是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Redis-%E4%B8%AD%E7%9A%84%E7%83%AD%E7%82%B9-key-%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.0.18.</span> <span class="toc-text">如何解决 Redis 中的热点 key 问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.19.</span> <span class="toc-text">Redis 集群的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%AD%E7%9A%84-Big-Key-%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.0.20.</span> <span class="toc-text">Redis 中的 Big Key 问题是什么？如何解决？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/22/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/" title="Java基础八股文">Java基础八股文</a><time datetime="2025-01-22T07:20:21.000Z" title="发表于 2025-01-22 15:20:21">2025-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统常见八股文">操作系统常见八股文</a><time datetime="2025-01-18T07:20:21.000Z" title="发表于 2025-01-18 15:20:21">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/" title="计算机网络常见八股文">计算机网络常见八股文</a><time datetime="2025-01-14T07:20:21.000Z" title="发表于 2025-01-14 15:20:21">2025-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式常见八股文">设计模式常见八股文</a><time datetime="2025-01-09T07:20:21.000Z" title="发表于 2025-01-09 15:20:21">2025-01-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/07/Redis%E5%85%AB%E8%82%A1%E6%96%87/" title="Redis常见八股文">Redis常见八股文</a><time datetime="2025-01-07T07:20:21.000Z" title="发表于 2025-01-07 15:20:21">2025-01-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By H-Loong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://h-loong.github.io/2025/01/07/Redis%E5%85%AB%E8%82%A1%E6%96%87/'
    this.page.identifier = '/2025/01/07/Redis%E5%85%AB%E8%82%A1%E6%96%87/'
    this.page.title = 'Redis常见八股文'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>